{"file":"/Users/devprofile/Documents/GitHub/musafir_backend/src/notifications/notifications.gateway.ts","mappings":"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","names":[],"sources":["/Users/devprofile/Documents/GitHub/musafir_backend/src/notifications/notifications.gateway.ts"],"sourcesContent":["import {\n  ConnectedSocket,\n  MessageBody,\n  OnGatewayConnection,\n  OnGatewayDisconnect,\n  SubscribeMessage,\n  WebSocketGateway,\n  WebSocketServer,\n} from '@nestjs/websockets';\nimport { UseGuards, Logger } from '@nestjs/common';\nimport { Server, Socket } from 'socket.io';\nimport { JwtWsGuard } from 'src/auth/guards/jwt-ws.guard';\nimport Cryptr from 'cryptr';\nimport { JwtService } from '@nestjs/jwt';\nimport { NotificationDto } from './dto/notification.dto';\n\n@WebSocketGateway({\n  namespace: '/notifications',\n  cors: { origin: '*', credentials: true },\n})\nexport class NotificationsGateway\n  implements OnGatewayConnection, OnGatewayDisconnect\n{\n  @WebSocketServer()\n  server: Server;\n\n  private logger = new Logger('NotificationsGateway');\n\n  constructor(private readonly jwtService: JwtService) {}\n\n  async handleConnection(client: Socket) {\n    try {\n      const userId = await this.authenticate(client);\n      client.join(this.userRoom(userId));\n      this.logger.debug(`Client connected for user ${userId}`);\n    } catch (error) {\n      this.logger.warn(`Socket connection rejected: ${error.message}`);\n      client.disconnect(true);\n    }\n  }\n\n  handleDisconnect(client: Socket) {\n    const userId = (client as any).userId;\n    this.logger.debug(`Client disconnected${userId ? ` for user ${userId}` : ''}`);\n  }\n\n  @UseGuards(JwtWsGuard)\n  @SubscribeMessage('notifications:read')\n  async handleClientRead(\n    @ConnectedSocket() client: Socket,\n    @MessageBody() payload: { id: string },\n  ) {\n    // The REST endpoint will persist read state; this is a soft ack only\n    const userId = (client as any).user?.userId;\n    if (userId && payload?.id) {\n      client.to(this.userRoom(userId)).emit('notifications:read', payload.id);\n    }\n  }\n\n  sendNewNotification(userId: string, notification: NotificationDto) {\n    this.server.to(this.userRoom(userId)).emit('notifications:new', notification);\n  }\n\n  sendRead(userId: string, notificationId: string) {\n    this.server.to(this.userRoom(userId)).emit('notifications:read', notificationId);\n  }\n\n  sendReadAll(userId: string) {\n    this.server.to(this.userRoom(userId)).emit('notifications:read-all');\n  }\n\n  private async authenticate(client: Socket): Promise<string> {\n    const token = this.extractToken(client);\n    if (!token) {\n      throw new Error('Missing token');\n    }\n    const cryptr = new Cryptr(process.env.ENCRYPT_JWT_SECRET);\n    const decrypted = cryptr.decrypt(token);\n    const payload = await this.jwtService.verifyAsync(decrypted, {\n      secret: process.env.JWT_SECRET,\n    });\n    if (!payload?.userId) {\n      throw new Error('Invalid token payload');\n    }\n    (client as any).userId = payload.userId;\n    return payload.userId;\n  }\n\n  private extractToken(client: Socket): string | null {\n    const fromHeader = client.handshake.headers.authorization;\n    if (fromHeader?.startsWith('Bearer ')) {\n      return fromHeader.replace('Bearer ', '').trim();\n    }\n    if (client.handshake.auth && typeof client.handshake.auth.token === 'string') {\n      return client.handshake.auth.token;\n    }\n    if (client.handshake.query && typeof client.handshake.query.token === 'string') {\n      return client.handshake.query.token as string;\n    }\n    return null;\n  }\n\n  private userRoom(userId: string) {\n    return `user:${userId}`;\n  }\n}\n"],"version":3}